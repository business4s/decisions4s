---
sidebar_position: 1
#sidebar_label: Getting Started
---

# Getting Started

To get a glimpse of what `Decisions4s` can do, we'll model rules governing a pull request process.

We want to define four rules:
* An unprotected branch requires 1 approval.
* A protected branch requires 2 approvals.
* An admin can merge anything without approvals, but this sends a notification.
* Nothing can be merged otherwise.

As the first step, add the following dependency to your project:

import SbtDependency from '@site/src/components/SbtDependency';

<SbtDependency moduleName={"decisions4s-core"}/>

## Defining the Rules

We start by defining the input and output of the decision:

```scala file=./main/scala/decisions4s/example/docs/PullRequestDecision.scala start=start_imports end=end_imports
```

```scala file=./main/scala/decisions4s/example/docs/PullRequestDecision.scala start=start_shapes end=end_shapes
```

We take three values as input and provide two values as output.
Both input and output are defined as case classes, with each field wrapped in the F[_] type parameter.
This pattern is sometimes referred to as Higher Kinded Data,
which is also the name of the typeclass automatically derived for our types.

Now let's define the rules:

```scala file=./main/scala/decisions4s/example/docs/PullRequestDecision.scala start=start_rules end=end_rules
```

And create a decision:

```scala file=./main/scala/decisions4s/example/docs/PullRequestDecision.scala start=start_table end=end_table
```

By doing this, we specified a name that will be used for the generated diagram.
We also defined the [hit policy](features/hit-policies), which in our case will capture the first satisfied rule.

## Evaluating the Decision

Now we can evaluate our decision:

```scala file=./main/scala/decisions4s/example/docs/PullRequestDecision.scala start=start_evaluate end=end_evaluate
```

It works!

## Understanding the decision

But you might wonder why the given decision was made. Wonder no more!

```scala file=./main/scala/decisions4s/example/docs/PullRequestDecision.scala start=start_diagnose end=end_diagnose
```

Which gives us the following:

```text file=./test/resources/docs/pull-request-diagnostics.txt
```

This not only tells us which rules were satisfied but also shows the results of specific predicates.
This way, we can easily understand what happened!

## Visualizing the Logic

Let's see how our logic presents itself in a more concise and human-friendly way:

```scala file=./main/scala/decisions4s/example/docs/PullRequestDecision.scala start=start_markdown end=end_markdown
```
That's the output:

import MDOutput from '../../decisions4s-examples/src/test/resources/docs/pull-request-markdown.md'

<MDOutput/>

And if that's not enough, we can also generate the DMN diagram. To do this, we need to add another dependency:

<SbtDependency moduleName={"decisions4s-dmn"}/>

And use the provided utilities:

```scala file=./main/scala/decisions4s/example/docs/PullRequestDecision.scala start=start_dmn end=end_dmn
```

Now if we open this file in [bpmn.io](https://bpmn.io/toolkit/dmn-js/) or Camunda Modeler, we will see the following
table:

<!-- TODO this should be autogenerated in the pipeline -->
![PullRequestDecision.png](./assets/PullRequestDecision.png)

This can now be shared with non-technical folks or saved as documentation!